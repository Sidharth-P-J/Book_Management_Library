"""
AI and recommendation routes.

This module provides endpoints for generating summaries
and book recommendations using LLM models.
"""

import logging
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import datetime

from src.core import get_db
from src.schemas import SummaryGenerateRequest, SummaryResponse, RecommendationRequest, RecommendationResponse
from src.services import RecommendationService
from src.utils import llm_service
from src.auth import get_current_user

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/ai", tags=["AI & Recommendations"])


@router.post("/generate-summary", response_model=SummaryResponse)
async def generate_summary(
    request: SummaryGenerateRequest,
    current_user: dict = Depends(get_current_user),
):
    """
    Generate a summary for book content using LLM.

    Args:
        request: Summary generation request data
        current_user: Current authenticated user

    Returns:
        Generated summary

    Raises:
        HTTPException: If summary generation fails
    """
    try:
        summary = llm_service.generate_summary(
            title=request.title,
            author=request.author,
            content=request.content,
            max_tokens=request.max_tokens,
        )

        logger.info(f"Summary generated by user {current_user.get('sub')}")
        return SummaryResponse(
            summary=summary,
            generated_at=datetime.utcnow(),
        )
    except RuntimeError as e:
        logger.error(f"Error generating summary: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=str(e)
        ) from e
    except Exception as e:
        logger.error(f"Unexpected error generating summary: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error generating summary"
        ) from e


@router.post("/recommendations", response_model=RecommendationResponse)
async def get_recommendations(
    request: RecommendationRequest,
    session: AsyncSession = Depends(get_db),
    current_user: dict = Depends(get_current_user),
):
    """
    Get personalized book recommendations.

    Args:
        request: Recommendation request data
        session: Database session
        current_user: Current authenticated user

    Returns:
        Recommended books with reasoning
    """
    try:
        if request.based_on_reviews:
            # Get recommendations based on user's review history
            recommendations = await RecommendationService.get_user_recommendations(
                session, request.user_id, request.limit
            )
            criteria = f"Based on user's review history"
        elif request.genre:
            # Get recommendations by genre
            recommendations = await RecommendationService.get_recommendations_by_genre(
                session, request.genre, request.limit
            )
            criteria = f"Based on genre: {request.genre}"
        else:
            # Get popular books
            recommendations = await RecommendationService.get_popular_books(
                session, request.limit
            )
            criteria = "Popular books"

        logger.info(f"Recommendations generated for user {current_user.get('sub')}")
        return RecommendationResponse(
            recommendations=recommendations,
            criteria=criteria,
            generated_at=datetime.utcnow(),
        )
    except Exception as e:
        logger.error(f"Error getting recommendations: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error generating recommendations"
        ) from e


@router.get("/recommendations/genre/{genre}", response_model=dict)
async def get_recommendations_by_genre(
    genre: str,
    session: AsyncSession = Depends(get_db),
    limit: int = Query(5, ge=1, le=20),
    current_user: dict = Depends(get_current_user),
):
    """
    Get book recommendations by genre.

    Args:
        genre: Genre to recommend books from
        session: Database session
        limit: Number of recommendations
        current_user: Current authenticated user

    Returns:
        Recommended books for the genre
    """
    try:
        recommendations = await RecommendationService.get_recommendations_by_genre(
            session, genre, limit
        )

        logger.info(f"Genre recommendations generated for user {current_user.get('sub')}: {genre}")
        return {
            "genre": genre,
            "recommendations": recommendations,
            "count": len(recommendations),
            "generated_at": datetime.utcnow(),
        }
    except Exception as e:
        logger.error(f"Error getting genre recommendations: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error generating recommendations"
        ) from e


@router.get("/recommendations/popular", response_model=dict)
async def get_popular_books(
    session: AsyncSession = Depends(get_db),
    limit: int = Query(5, ge=1, le=20),
    current_user: dict = Depends(get_current_user),
):
    """
    Get popular book recommendations.

    Args:
        session: Database session
        limit: Number of recommendations
        current_user: Current authenticated user

    Returns:
        Popular books
    """
    try:
        recommendations = await RecommendationService.get_popular_books(
            session, limit
        )

        logger.info(f"Popular book recommendations generated for user {current_user.get('sub')}")
        return {
            "criteria": "Popular books (highest rated with multiple reviews)",
            "recommendations": recommendations,
            "count": len(recommendations),
            "generated_at": datetime.utcnow(),
        }
    except Exception as e:
        logger.error(f"Error getting popular books: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error generating recommendations"
        ) from e


@router.get("/recommendations/similar/{book_id}", response_model=dict)
async def get_similar_books(
    book_id: int,
    session: AsyncSession = Depends(get_db),
    limit: int = Query(5, ge=1, le=20),
    current_user: dict = Depends(get_current_user),
):
    """
    Get books similar to a given book.

    Args:
        book_id: Reference book ID
        session: Database session
        limit: Number of recommendations
        current_user: Current authenticated user

    Returns:
        Similar books

    Raises:
        HTTPException: If reference book not found
    """
    try:
        from src.services import BookService
        book = await BookService.get_book_by_id(session, book_id)
        if not book:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Book not found"
            )

        recommendations = await RecommendationService.get_similar_books(
            session, book_id, limit
        )

        logger.info(f"Similar book recommendations generated for user {current_user.get('sub')}")
        return {
            "reference_book": book.title,
            "criteria": f"Similar to '{book.title}' (same genre: {book.genre})",
            "recommendations": recommendations,
            "count": len(recommendations),
            "generated_at": datetime.utcnow(),
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting similar books: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error generating recommendations"
        ) from e
